
//
// Copyright (c) 2013 Limit Point Systems, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

/// @example examples/read_domain.t.cc

#include "SheafSystem/std_iostream.h"
#include "SheafSystem/namespace_poset.h"
#include "SheafSystem/poset_bounds_descriptor.h"
#include "SheafSystem/sec_rep_space.h"
#include "SheafSystem/storage_agent.h"

using namespace std;
using namespace fiber_bundle;

string filename;

int
main(int argc, char** argv)
{

  if (argc > 1)
  {
    filename = argv[1];
  }
  else
  {
    cerr << "usage: read_domain.t sheaf_file domain_id\n";
    exit(0);
  }

  int domain_id;

  if (argc > 2)
  {
    domain_id = atoi(argv[2]);
  }
  else
  {
    cerr << "usage: read_domain.t sheaf_file domain_id\n";
    exit(0);
  }

  cout << "@error" << endl
  << "This program is intended to read a single domain " << endl
  << "from a polyline mesh generated by polyline.t.cc" << endl
  << "However, polyline.t.cc is not up to date and doesn't " << endl
  << "currently generate a valid domain decomposed output file." << endl
  << "This program executes, but does not properly read a single domain."
  << endl;



  // Make the default namespace

  namespace_poset ns("test");

  // Read the namespace from the file;
  // need write access in order to read it.

  ns.get_read_write_access();
  storage_agent sa(filename, sheaf_file::READ_ONLY, false);
  sa.put_member_record_buffer_ub(15);
  sa.put_dof_tuple_record_buffer_ub(15);

  // Read the namespace poset

  sa.read(ns);

  // Attach a poset handle to the mesh poset

  poset* p = ns.member_poset<poset>(string("polyline"), false);

  // Read the table of contents of the poset.

  //   sa.read_toc(p);

  // Read domain_0.

  p->get_read_write_access();

  cout << *p << endl;


  poset_member domain(p, "domain_0");

  poset_bounds_descriptor domain_bounds(poset_bounds_descriptor::MEMBER_MEMBER,
                                        BOTTOM_INDEX,
                                        domain.index());

  //   sa.read(p, domain_bounds);

  // Output a text version to stdout

  cout << *p << endl;

  p->release_access();

  // Detach the handles before
  // their destructors get called to avoid
  // them complaining about needing access.

  domain.detach_from_state();


  return 0;
}
